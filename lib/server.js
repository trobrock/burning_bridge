// Generated by CoffeeScript 1.7.1
(function() {
  var Client, Command, Rooms, Server, User, carrier, configuration, fs, handler, net, s, server;

  net = require("net");

  carrier = require("carrier");

  fs = require("fs");

  User = require("./user.js").User;

  Command = require("./command.js").Command;

  Rooms = require("./rooms.js").Rooms;

  require('longjohn');

  configuration = JSON.parse(fs.readFileSync("./config/config.json").toString());

  String.prototype.snakeCase = function() {
    return this.split(" ").map(function(word) {
      return word.toLowerCase();
    }).join("_");
  };

  Client = (function() {
    function Client(socket) {
      this.socket = socket;
    }

    Client.prototype.send = function(message) {
      console.log("[s] :" + message);
      return this.socket.write(":" + message + "\r\n");
    };

    return Client;

  })();

  Server = (function() {
    function Server() {}

    Server.prototype.clients = [];

    Server.prototype.rooms = new Rooms();

    Server.prototype.hostname = "localhost";

    Server.prototype.events = {
      welcome: "001",
      yourHost: "002",
      created: "003",
      myInfo: "004",
      motdStart: "375",
      motd: "372",
      motdEnd: "376",
      listStart: "321",
      list: "322",
      listEnd: "323",
      topic: "332",
      noTopic: "331",
      namesReply: "353",
      endNames: "366"
    };

    Server.prototype.add_client = function(client) {
      return this.clients.push(client);
    };

    Server.prototype.remove_client = function(client) {
      return this.clients.splice(this.clients.indexOf(client), 1);
    };

    Server.prototype.broadcast_event = function(client, event, msg) {
      return this.broadcast(client, "" + this.events[event] + " " + msg);
    };

    Server.prototype.broadcast = function(client, msg) {
      return client.send("" + this.hostname + " " + msg);
    };

    Server.prototype.message = function(client, user, msg) {
      return client.send("" + (user.mask()) + " " + msg);
    };

    Server.prototype.pong = function(client) {
      return this.broadcast(client, "PONG " + this.hostname + " :" + this.hostname);
    };

    Server.prototype.welcome = function(client, user) {
      this.broadcast_event(client, "welcome", "" + (user.nick()) + " Welcome " + (user.mask()));
      this.broadcast_event(client, "yourHost", "" + (user.nick()) + " Your host");
      this.broadcast_event(client, "created", "" + (user.nick()) + " This server was created");
      return this.broadcast_event(client, "myInfo", "" + (user.nick()) + " myIrcServer 0.0.1");
    };

    Server.prototype.motd = function(client, user) {
      this.broadcast_event(client, "motdStart", "" + (user.nick()) + " :- Message of the Day -");
      this.broadcast_event(client, "motd", "" + (user.nick()) + " myIrcServer 0.0.1");
      return this.broadcast_event(client, "motdEnd", "" + (user.nick()) + " :End of /MOTD command.");
    };

    Server.prototype.list = function(client, user) {
      var room, _i, _len, _ref;
      this.broadcast_event(client, "listStart", "" + (user.nick()) + " Channel :Users  Name");
      _ref = this.rooms.rooms;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        room = _ref[_i];
        this.broadcast_event(client, "list", "" + (user.nick()) + " " + (room.name.snakeCase()) + " " + room.users.length + " :[]");
      }
      return this.broadcast_event(client, "listEnd", "" + (user.nick()) + " :End of /LIST");
    };

    return Server;

  })();

  server = new Server();

  handler = function(socket) {
    var client, current_user;
    current_user = null;
    client = new Client(socket);
    server.add_client(client);
    carrier.carry(socket, function(line) {
      var api_token, channel, command, message, r, room, subdomain, target, user, users, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      command = Command.parse(line);
      console.log("[r] " + command.command + " with args " + command.args);
      switch (command.command) {
        case "PASS":
          _ref = command.args[0].split(":"), subdomain = _ref[0], api_token = _ref[1];
          return current_user = new User(subdomain, api_token, client);
        case "NICK":
          if (!current_user.nick()) {
            return current_user.nick(command.args[0]);
          }
          break;
        case "USER":
          current_user.username = command.args[0];
          current_user.hostname = command.args[1];
          server.welcome(client, current_user);
          return server.motd(client, current_user);
        case "PING":
          return server.pong(client);
        case "MODE":
          target = command.args[0];
          if (target.match(/^\#/)) {
            if (command.args[1]) {
              return server.message(client, current_user, "MODE " + target + " " + command.args[1] + " " + (current_user.nick()));
            }
          }
          break;
        case "LIST":
          return server.list(client, current_user);
        case "NAMES":
          channel = command.args[0];
          room = null;
          _ref1 = server.rooms.rooms;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            r = _ref1[_i];
            if (r.name.snakeCase() === channel.replace("#", "")) {
              room = r;
            }
          }
          users = (function() {
            var _j, _len1, _ref2, _results;
            _ref2 = room.users;
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              user = _ref2[_j];
              _results.push(user.name.snakeCase());
            }
            return _results;
          })();
          server.broadcast_event(client, "namesReply", "" + (current_user.nick()) + " = " + channel + " :" + (users.join(" ")));
          return server.broadcast_event(client, "endNames", "" + (current_user.nick()) + " " + channel + " :End of /NAMES list.");
        case "JOIN":
          channel = command.args[0];
          room = null;
          _ref2 = server.rooms.rooms;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            r = _ref2[_j];
            if (r.name.snakeCase() === channel.replace("#", "")) {
              room = r;
            }
          }
          users = (function() {
            var _k, _len2, _ref3, _results;
            _ref3 = room.users;
            _results = [];
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              user = _ref3[_k];
              _results.push(user.name.snakeCase());
            }
            return _results;
          })();
          return room.join(function() {
            server.message(client, current_user, "JOIN " + channel);
            if (room.topic) {
              server.broadcast_event(client, "topic", "" + (current_user.nick()) + " " + channel + " :" + room.topic);
            } else {
              server.broadcast_event(client, "noTopic", "" + (current_user.nick()) + " " + channel + " :No topic is set");
            }
            server.broadcast_event(client, "namesReply", "" + (current_user.nick()) + " = " + channel + " :" + (users.join(" ")));
            server.broadcast_event(client, "endNames", "" + (current_user.nick()) + " " + channel + " :End of /NAMES list.");
            return server.rooms.on("message:" + channel, (function(_this) {
              return function(message) {
                var _ref3;
                if (message.userId === current_user.id) {
                  return;
                }
                if ((_ref3 = message.type) !== "TextMessage" && _ref3 !== "PasteMessage") {
                  return;
                }
                user = new User(configuration.subdomain, configuration.token, client, message.userId);
                return user.once("fetched", function() {
                  var name;
                  console.log(user);
                  name = user.real_name.snakeCase();
                  return server.message(client, user, "PRIVMSG " + channel + " :" + message.body);
                });
              };
            })(this));
          });
        case "PRIVMSG":
          channel = command.args[0];
          message = command.args.slice(1).join(" ").substr(1);
          return current_user.speak_in_room(channel, message);
        case "PART":
          channel = command.args[0];
          message = command.args[1].substr(1);
          return current_user.leave_room(channel, message);
      }
    });
    socket.on("end", function() {
      server.remove_client(client);
      return console.log("Client disconnected");
    });
    return socket.on("error", function(e) {
      return console.log("[socket] Caught fatal error:", e);
    });
  };

  s = net.createServer(handler);

  s.listen(6666, function() {
    return console.log("Started listening on 6666");
  });

  s.on("error", function(e) {
    return console.log("[server] Caught fatal error:", e);
  });

}).call(this);
